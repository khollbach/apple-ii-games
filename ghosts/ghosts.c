#include <conio.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>
#include <stdbool.h>

typedef uint8_t u8;
typedef uint16_t u16;

bool is_dir(u8 key);
const u8 *ghost_sprite(u8 dir);
u8 rotate_clockwise(u8 dir);
void draw_sprite(const u8 *sprite);
void draw_pixel(u8 x, u8 y, u8 color);
void gr();
void gr_clear();
void clear_input_buffer();
u16 gr_coord_to_addr(u8 x, u8 y);

#define ADDR(a) ((volatile char *) a)
#define READ(a) (*ADDR(a))
#define WRITE(a, x) (*ADDR(a) = x)

const u8 sprite_size = 14;

const u8 blinky[14][14] = {
    {0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
    {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
    {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
    {0, 1, 1, 1,15,15, 1, 1, 1, 1,15,15, 1, 0},
    {0, 1, 1,15,15,15,15, 1, 1,15,15,15,15, 0},
    {0, 1, 1,15,15, 2, 2, 1, 1,15,15, 2, 2, 0},
    {1, 1, 1,15,15, 2, 2, 1, 1,15,15, 2, 2, 1},
    {1, 1, 1, 1,15,15, 1, 1, 1, 1,15,15, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1},
    {0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0},
};

const u8 pinky[14][14] = {
    {0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0},
    {0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0},
    {0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0},
    {0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0},
    {0, 3, 3,15,15, 3, 3, 3, 3,15,15, 3, 3, 0},
    {0, 3,15,15,15,15, 3, 3,15,15,15,15, 3, 0},
    {3, 3,15,15,15,15, 3, 3,15,15,15,15, 3, 3},
    {3, 3,15, 2, 2,15, 3, 3,15, 2, 2,15, 3, 3},
    {3, 3, 3, 2, 2, 3, 3, 3, 3, 2, 2, 3, 3, 3},
    {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
    {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
    {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
    {3, 3, 3, 3, 0, 3, 3, 3, 3, 0, 3, 3, 3, 3},
    {0, 3, 3, 0, 0, 0, 3, 3, 0, 0, 0, 3, 3, 0},
};

const u8 inky[14][14] = {
    {0, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0},
    {0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0},
    {0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0},
    {0, 6,15,15, 6, 6, 6, 6, 6, 6,15,15, 6, 0},
    {0,15,15,15,15, 6, 6, 6, 6,15,15,15,15, 0},
    {0, 2, 2,15,15, 6, 6, 6, 6, 2, 2,15,15, 0},
    {6, 2, 2,15,15, 6, 6, 6, 6, 2, 2,15,15, 6},
    {6, 6,15,15, 6, 6, 6, 6, 6, 6,15,15, 6, 6},
    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
    {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
    {6, 6, 6, 6, 0, 6, 6, 6, 6, 0, 6, 6, 6, 6},
    {0, 6, 6, 0, 0, 0, 6, 6, 0, 0, 0, 6, 6, 0},
};

const u8 clyde[14][14] = {
    {0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 0},
    {0, 0, 0, 2, 2, 9, 9, 9, 9, 2, 2, 0, 0, 0},
    {0, 0,15, 2, 2,15, 9, 9,15, 2, 2,15, 0, 0},
    {0, 9,15,15,15,15, 9, 9,15,15,15,15, 9, 0},
    {0, 9,15,15,15,15, 9, 9,15,15,15,15, 9, 0},
    {0, 9, 9,15,15, 9, 9, 9, 9,15,15, 9, 9, 0},
    {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
    {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
    {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
    {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
    {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
    {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
    {9, 9, 9, 9, 0, 9, 9, 9, 9, 0, 9, 9, 9, 9},
    {0, 9, 9, 0, 0, 0, 9, 9, 0, 0, 0, 9, 9, 0},
};

const u8 vulnerable[14][14] = {
    {0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0},
    {0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0},
    {0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0},
    {0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0},
    {0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0},
    {0, 2, 2, 2, 7, 7, 2, 2, 7, 7, 2, 2, 2, 0},
    {2, 2, 2, 2, 7, 7, 2, 2, 7, 7, 2, 2, 2, 2},
    {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
    {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
    {2, 2, 7, 7, 2, 2, 7, 7, 2, 2, 7, 7, 2, 2},
    {2, 7, 2, 2, 7, 7, 2, 2, 7, 7, 2, 2, 7, 2},
    {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
    {2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2},
    {0, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 0},
};

const u8 secret[14][14] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0},
    {0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 8, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0},
    {0, 0, 1, 1, 1, 8, 0, 0, 0, 8, 0, 0, 0, 0},
    {0, 1, 1, 1, 8, 1, 1, 0, 8, 0, 0, 0, 0, 0},
    {0, 1, 1, 1, 1, 1, 0, 1, 8, 1, 1, 0, 0, 0},
    {0, 1,15, 1, 1, 0, 1, 1, 8, 1, 1, 1, 0, 0},
    {0, 1, 1,15, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0},
    {0, 0, 1, 1, 1, 0, 1,15, 1, 1, 1, 1, 0, 0},
    {0, 0, 0, 0, 0, 0, 1, 1,15, 1, 1, 1, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

const u8 blank[14][14] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

enum key_code {
    up = 11,
    down = 10,
    left = 8,
    right = 21,
};

const u8 code[8] = {up, up, down, down, left, right, left, right};

int main() {
    u8 dir, key, i;
    bool vuln;

    u8 buf[16] = {0};
    u8 buf_len = 0;

    gr();
    gr_clear();

    dir = right;
    vuln = false;

    while (1) {
        if (vuln) {
            draw_sprite(&vulnerable[0][0]);
        } else {
            draw_sprite(ghost_sprite(dir));
        }

        // Activate easter egg.
        if (buf_len >= 8 && memcmp(buf + (buf_len - 8), code, 8) == 0) {
            draw_sprite(&secret[0][0]);
            clear_input_buffer();
        }

        key = cgetc();
        if (buf_len == 16) {
            memcpy(buf, buf + 8, 8);
            buf_len = 8;
        }
        buf[buf_len++] = key;

        if (is_dir(key)) {
            if (key == dir) {
                vuln ^= true;
            } else {
                dir = key;
                vuln = false;
            }
        } else {
            if (vuln) {
                vuln = false;
            } else {
                dir = rotate_clockwise(dir);
            }
        }
    }

    assert(false); // unreachable
    return 0;
}

bool is_dir(u8 key) {
    switch (key) {
    case up:
    case down:
    case left:
    case right:
        return true;
    default:
        return false;
    }
}

const u8 *ghost_sprite(u8 dir) {
    assert(is_dir(dir));

    switch (dir) {
    case right:
        return &blinky[0][0];
    case down:
        return &pinky[0][0];
    case left:
        return &inky[0][0];
    case up:
        return &clyde[0][0];
    }
}

u8 rotate_clockwise(u8 dir) {
    assert(is_dir(dir));

    switch (dir) {
    case right:
        return down;
    case down:
        return left;
    case left:
        return up;
    case up:
        return right;
    }
}

void draw_sprite(const u8 *sprite) {
    u8 x, y;
    for (y = 0; y < sprite_size; y++) {
        for (x = 0; x < sprite_size; x++) {
            draw_pixel(x, y, sprite[y * sprite_size + x]);
        }
    }
}

void draw_pixel(u8 x, u8 y, u8 color) {
    WRITE(gr_coord_to_addr(x, y), color | color << 4);
}

// Activate graphics mode.
void gr() {
    WRITE(0xC050, 0);
}

void gr_clear() {
    // Note that this clobbers screen holes.
    memset((void *) ADDR(0x400), 0, 0x400);
}

// Consume any pending keypresses in the keyboard input buffer.
void clear_input_buffer() {
    while (kbhit()) {
        cgetc();
    }
}

u16 gr_coord_to_addr(u8 x, u8 y) {
    u8 group;
    u16 base, offset;
    assert(x < 40);
    assert(y < 24);

    group = y / 8;
    switch (group) {
    case 0:
        base = 0x400;
        break;
    case 1:
        base = 0x428;
        break;
    case 2:
        base = 0x450;
        break;
    }

    offset = y % 8 * 0x80;

    return base + offset + x;
}
